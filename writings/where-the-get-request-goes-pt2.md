# Where your GET goes for `https://ayaanjaved.in/` (Part 2)

**Summary:** Picking up after TLS. Once the handshake finishes, the proxy on `23.88.0.53` decides whether it can serve a static asset or needs to wake the Next.js runtime. This note walks that path for our project.

---

## 1. Reverse proxy hands off

The host behind `linux11.hostguy.com` is almost certainly running a reverse
proxy (Nginx/Apache/Caddy). After TLS terminates, that proxy:

1. Checks its file cache/root (`/var/www/...`) for an exact match (`/index.html`, `/favicon.ico`, etc.).
2. If the file exists, it streams it directly back. If not, it forwards the request upstream - typically to a Node process listening on a high port (for example 3000).

Because our project uses `next.config.ts` with `output: 'export'`, the production deploy most likely drops the pre-rendered files from `out/` onto that webroot. In that setup **step 1 succeeds**: `/index.html` exists, so the proxy responds without involving Node at all.

---

## 2. When Node *is* involved

Locally we run `next dev --turbopack`, so the proxy step is skipped and the request lands on the Next.js dev server. In production, Node would only be involved if:

- we removed `output: 'export'` and shipped an SSR build; or
- we configured the proxy to pass everything through to Node regardless of static availability.

In either case the flow looks like this:

```
proxy (443) -> Node process (app server) -> Next.js request pipeline
```

The Next.js pipeline then:

1. Normalises the URL and headers.
2. Runs App Router middleware (we currently have none, so this step is a no-op).
3. Resolves the route inside `app/` (for `/` that is `src/app/page.tsx`).
4. Composes the nearest layout stack (`layout.tsx`, nested layouts, etc.).
5. Streams the HTML payload, interleaving `<head>` metadata produced from the exported `metadata` objects.

---

## 3. Static export specifics for this project

Since we ship an exported build:

- `next build && next export` writes `out/index.html`, CSS, and JS bundles.
- Those bundles are the `_next/static/...` paths referenced in the HTML we captured earlier.
- At deploy time we need those `_next/static` assets on disk alongside `index.html`; otherwise clients will see unstyled markup (exactly what happened when we opened `out/index.html` directly without a server).

So in production the proxy serves:

```
/index.html              -> our hero shell
/_next/static/...css     -> Tailwind + font styles
/_next/static/...js      -> hydration bundles, GSAP, etc.
```

No Node code executes once the files are in place; the proxy is effectively a static file host.

---

## 4. What wakes up on the client

After the HTML lands in the browser, the `_next/static/...js` bundles hydrate the React tree generated by `src/app/page.tsx`. That is when client-side behaviour (hover fades, GSAP hooks) comes alive.

Because we rely on exported HTML, hydration is essential - without those JS bundles the page remains the static skeleton we saw in the headless screenshot.

---

## Takeaway

For this project the "GET" request usually never reaches a Node runtime in production; the reverse proxy ends the journey by serving the prebuilt files from `out/`. Understanding that distinction makes it easy to reason about deploy bugs: missing `_next/static` files -> broken styling; proxy misrouting -> 404; running with full SSR -> the proxy must forward to the Next.js app server so that `layout.tsx` and `page.tsx` can render on demand.
